\documentclass[11pt, oneside]{scrartcl}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   		% ... or a4paper or a5paper or ... 

\usepackage{graphicx}				% Use pdf, png, jpg, or epsÂ§ with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{amssymb}
\usepackage{listings}

%SetFonts

%SetFonts
\lstset{language=C} 

\title{Embedded Systems Exam Bonus Project}
\subtitle{Project name: Green Gardening}
\author{Contributers: Leander Lauenburg, Christoph Clement, Anselm Coogan}
\date{18.01.18}	

\begin{document}
\maketitle
\section{Hardware}
\section{Software}

As stated in the previous chapter we used the free IDE \emph{PsoC Creator} to program the micro controller. This software offers a three layer approach. 

In the first layer, the top design, you can graphically configure the technical layout and wiring of the components you are using from the micro controller. In the second layer you assign the actual pins of the board to the different components configured in the top design. Lastly, the third layer is writing the code that is executed on the micro controller.

The entire source code discussed here (and successive versions) can be inspected in this git repository: https://github.com/AnselmC/GreenGardening

\subsection{Top design}

The top design enables you to easily make a circuit diagram for your project. You have access to all the actual components of the micro controller, as well as so-called off-board components that are there for documentation and clarification purposes only (colored blue). The components we used for this project are: a real-time clock, a universal asynchronous receiver transmitter, and digital input and output pins.

\subsubsection{Real-time clock}

The built-in real-time clock component can be configured extensively and has a resolution of one second. We set the clock to use the 24-hour time format and synched it to Central European Time.

\subsubsection{UART}

The universal asynchronous receiver transmitter component allows for setting up a bidirectional data connection on a given port. We are using this for debugging purposes. 

\subsubsection{Digital input pins}

The input pins in our project are the light sensor and the moisture sensor. We configured these input pins to have dedicated interrupts. The interrupt for the light sensor is activated on both falling and rising edges, i.e. from light to dark and vice versa. This is because the light sensor is situated so that it is independent of the LED strips and only senses the environment light. Thus, if the LED's have been switched on because it was previously too dark and now the surrounding light suffices the LED's should be switched off. In contrast the interrupt for the moisture sensor is only activated on a falling edge, i.e. when it gets too dry. 

\subsubsection{Digital output pins}

As output pins we have set up the water pump and the LED strips.

\subsection{Pin connections}

The second layer is actually called \emph{Design Wide Resources}. However, we are only using the pin assignment part in our project. Here you get an overview of the micro controller  and can then assign the components configured in the top design with the components on the board and the components that have been connected via the digital or analog GPIO pins.

\subsection{C Code}

PsoC Creator automatically generates an API from the top design previously configured. This allows you to control all components with very little self-written C code.
In our main.c we have defined the following global variables used throughout our code:

\begin{itemize}
	\item WATERING\_TIME\_IN\_SEC: the time the watering pump should be on for one watering session
	\item STARTING\_HOUR and ENDING\_HOUR: the timeframe in which the plant should be exposed to light - in 24 h format (e.g. from STARTING\_HOUR: 10 to ENDING\_HOUR 20)
	\item NUMBER\_OF\_MEASUREMENTS: The number of measurements a sensor should make in one setting
	\item TIME\_BETWEEN\_MEASUREMENTS\_MILSEC: The time (in milliseconds) to wait between the single measurements
	\item BUFFER\_SIZE: The array size of the buffer used for writing debug information to the console
	\item ON and OFF: Macros used for more clarity in code
\end{itemize}

In order to use less CPU time and power, we are working with interrupts. There are two interrupts: one for the moisture sensor and one for the light sensor. The interrupts are triggered on both falling and rising edges of the sensors. This means that whenever the light changes from too dark to light or vice versa, or the moisture sensor changes from not moist enough to moist and vice versa the interrupts are called. In PsoC Creator these interrupts are configured in main.c as follows (for an arbitrary pin named Pin\_A):

\begin{lstlisting} [frame=single]
CY_ISR(<<name_of_interrupt_handler>>)
{
    /* Code to be executed on interrupt */
    
    Pin_A_ClearInterrupt();
}
\end{lstlisting}

The name of the interrupt handler can be whatever you choose. However, best practice is to name it \emph{Pin\_A\_Handler}. It is essential to clear the interrupt after the code has been executed, otherwise the interrupt can?t be called again. This is done with the generated \emph{Pin\_A\_ClearInterrupt()} function. In order to enable interrupt handling, in your \emph{main()} method you will need to call \emph{CyGlobalIntEnable}. Then, you need to initialize every interrupt like this: \emph{Pin\_A\_int\_StartEx(Pin\_A\_Handler)}
The StartEx function of your interrupt-enabled pin is also automatically generated by PsoC Creator. This means that in our project the \emph{main()} function solely consists of initializing the interrupts and an endless for-loop with no-code. Thus, the CPU can sleep until one of the sensors interrupts it. 

\begin{lstlisting}[frame=single]
int main(void)
{
    /* Enable global interrupts. */   
    CyGlobalIntEnable; 

    /* Place initialization/startup code here */
    UART_Start();
    RTC_Start();
    Pin_Light_Sensor_int_StartEx(Pin_Light_Sensor_Handler);
    Pin_Moisture_Sensor_int_StartEx(Pin_Moisture_Sensor_Handler);
    
    for(;;)
    {
        
    }
}
\end{lstlisting}

Our two interrupt functions each call one function, namely \emph{checkLight()} and \emph{checkMoisture()}.
\emph{checkLight()} first calls the real-time clock component to return the current time and then extracts the current hour. It then checks whether the returned hour is in the designated timeframe. If it isn't, the light is turned off and the function terminates. If it is, then we take a pre-defined amount of measurements (as configured in the global variables) with a pre-defined delay between each measurement. If the light sensor only measures enough light for less than half of the measurements, the LED's are turned on and the function terminates. Else, the lights are turned off and the function terminates.

\begin{lstlisting} [frame=single]
void checkLight()
{
    /* Get current hour */
    int hour = RTC_GetHours(RTC_GetTime());
    
    /* Check whether hour is outside of designated time frame 
    if so, turn it off */
    if(hour < STARTING_HOUR || hour > ENDING_HOUR){
        Pin_LED_blue_Write(OFF);
    }
    else {
        int positive_measurements = NUMBER_OF_MEASUREMENTS;
        /* Make several measurements of the light sensor */
        for(int i = 0; i < NUMBER_OF_MEASUREMENTS; i++){
            positive_measurements -= Pin_Light_Sensor_Read();
            CyDelay(TIME_BETWEEN_MEASUREMENTS_IN_MILSEC);
        }
        /* If the light sensor catches not enough light, 
        turn on the LED's */
        if (positive_measurements < NUMBER_OF_MEASUREMENTS/2)
        {
            Pin_LED_blue_Write(ON);   
        } 
        /* Else turn them off */
        else 
        {
            Pin_LED_blue_Write(OFF);
        }
    }
}
\end{lstlisting}

The \emph{checkMoisture()} function operates similarly. Again, we take a pre-defined amount of measurement to rule out anomalies. Then, if less than half of these measurements indicate that the soil is too dry, the water pump is turned on for a specified amount of time and then turned off again after which the function terminates. If the soil is moist enough, nothing happens and the function terminates.
\begin{lstlisting}[frame=single]
void checkMoisture()
{
    int positive_measurements = NUMBER_OF_MEASUREMENTS;
    /* Make several measurements of the moisture sensor */
    for(int i = 0; i < NUMBER_OF_MEASUREMENTS; i++){
        positive_measurements -= Pin_Moisture_Sensor_Read();
        CyDelay(TIME_BETWEEN_MEASUREMENTS_IN_MILSEC);
    }

    /* If the ground isn't wet enough, 
    water the plant for a specified amount of time */
    if (positive_measurements < NUMBER_OF_MEASUREMENTS/2)
    {
        /* Turn pump on */
        Pin_pump_Write(ON);
        /* Wait for specified amount of watering time */
        CyDelay(WATERING_TIME_IN_SEC * 1000);
        /* Turn pump off */
        Pin_pump_Write(OFF);
    }
}
\end{lstlisting}

Throughout the code we are outputting debug information that was critical for development. For this we are using the UART component. To use it it must be be initialized in the \emph{main()} method as can be seen above. Then, when you want to write to the connected pod (e.g. a terminal on your development machine) you can do so like this:

\begin{lstlisting}[frame=single]
sprintf(buffer, "Let's go\r\n");
UART_UartPutString(buffer);
\end{lstlisting}

\section{Learnings from the lecture}
\end{document}  